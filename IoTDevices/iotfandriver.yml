substitutions:
  name: "FanDriver1"

esphome:
  name: ducky-iotfandriver
  name_add_mac_suffix: true
  platform: esp32
  board: esp32-c3-devkitm-1

wifi:
  <<: !include ../wifi_config.yaml

# HASS API
api:

# Allow API
ota:

# Print Updates
logger:

# WebServer component, displays some information
web_server:
    port: 80

light:
  - platform: neopixelbus
    id: led
    variant: sk6812
    pin: GPIO5
    num_leds: 18
    name: "IoTFanDriver Neopixels"
    effects:
      - addressable_rainbow:
          name: Rainbow

output:
  - platform: ledc
    id: fan0_pwr
    pin: GPIO10
    frequency: 10 Hz
  - platform: ledc
    id: fan0_ctl
    pin: GPIO18
    inverted: true
    frequency: 25 kHz
  - platform: ledc
    id: fan1_pwr
    pin: GPIO3
    inverted: true
    frequency: 10 Hz
  - platform: ledc
    id: fan1_ctl
    pin: GPIO1
    inverted: true
    frequency: 25 kHz

fan:
  - platform: speed
    id: fan0_fan_pwr
    output: fan0_pwr
    name: "${name} Ch0 Drv"
  - platform: speed
    id: fan0_fan_ctl
    output: fan0_ctl
    name: "${name} Ch0 Ctl"
  - platform: speed
    id: fan1_fan_pwr
    output: fan1_pwr
    name: "${name} Ch1 Drv"
  - platform: speed
    id: fan1_fan_ctl
    output: fan1_ctl
    name: "${name} Ch1 Ctl"
    
sensor:
  - platform: adc
    name: "${name} Vin"
    pin: GPIO4
    accuracy_decimals: 2
    update_interval: 60s
    attenuation: 11dB
    filters:
      - multiply: 4.29
  - platform: rotary_encoder
    name: "${name} Encoder"
    pin_a:
      number: GPIO7
      inverted: true
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO6
      inverted: true
      mode:
        input: true
        pullup: true
    on_clockwise:
    - then:
        - lambda: |-
            esphome::fan::Fan* pwr_channels[] = {id(fan0_fan_pwr), id(fan1_fan_pwr)};
            esphome::fan::Fan* ctl_channels[] = {id(fan0_fan_ctl), id(fan1_fan_ctl)};
            for (int i=0; i<sizeof(pwr_channels)/sizeof(pwr_channels[0]); i++) {
              auto pwr = pwr_channels[i];
              auto ctl = ctl_channels[i];
              auto ctl_call = ctl->turn_on();
              if (ctl->state != false) {  // first turn when off only turns on the fan
                ctl_call.set_speed(ctl->speed + 1);
              }
              ctl_call.perform();
              if (pwr->state == false || pwr->speed <= 0) {
                pwr->turn_on().perform();
              }
            }
    on_anticlockwise:
    - then:
        - lambda: |-
            esphome::fan::Fan* pwr_channels[] = {id(fan0_fan_pwr), id(fan1_fan_pwr)};
            esphome::fan::Fan* ctl_channels[] = {id(fan0_fan_ctl), id(fan1_fan_ctl)};
            for (int i=0; i<sizeof(pwr_channels)/sizeof(pwr_channels[0]); i++) {
              auto pwr = pwr_channels[i];
              auto ctl = ctl_channels[i];
              if (ctl->speed <= 1) {
                auto ctl_call = ctl->turn_off();
                ctl_call.perform();
              } else {
                auto ctl_call = ctl->turn_on();
                ctl_call.set_speed(ctl->speed - 1);
                ctl_call.perform();
              }
              if (ctl->state == false && pwr->state == true) {
                pwr->turn_off().perform();
              }
            }

  - platform: pulse_counter
    pin: 
      number: GPIO19
      mode:
        input: true
        pullup: true
    name: "${name} Ch0 Tach"
    update_interval: 5s
  - platform: pulse_counter
    pin:
      number: GPIO0
      mode:
        input: true
        pullup: true
    name: "${name} Ch1 Tach"
    update_interval: 5s
