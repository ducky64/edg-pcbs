substitutions:
  name: "UsbSMU"

esphome:
  name: ducky-iotusbsmu
  name_add_mac_suffix: true
  platform: esp32
  board: esp32-s3-devkitc-1  # 8MB flash without PSRAM
  on_boot:
    - number.set:
        id: set_voltage
        value: 0
    - number.set:
        id: limit_current_min
        value: -0.1
    - number.set:
        id: limit_current_max
        value: 0.1
    - number.set:
        id: buckboost_ratio
        value: 0.0
    - switch.turn_on: conv_enable
    - delay: 0.1s
    - switch.turn_off: conv_enable

wifi:
  <<: !include ../wifi_config.yaml
  ap:
    ap_timeout: 15s

  reboot_timeout: 0s

# HASS API
api:
  reboot_timeout: 0s

# Allow API
ota:

# Print Updates
logger:
  level: INFO

# WebServer component, displays some information
web_server:
    port: 80
    local: true

# device constants
globals:
  - id: kBuckBoostPwmDeadzone
    type: float
    initial_value: '0.05'  # in fractional duty-cycle, maximum / minimum duty cycle
  - id: kBuckBoostHeadroom
    type: float
    initial_value: '1'  # volts

  - id: kVoltageRatio
    type: float
    initial_value: '23'  # 22/1, output volts per measured volt
  - id: kCurrentRatio0
    type: float
    initial_value: '2.2727'  # 1/(.022*20), output amps per measured volt, including accounting for resistor value
  - id: kCurrentRatio1
    type: float
    initial_value: '0.22727'  # 1/(.22*20)
  - id: kVCenter
    type: float
    initial_value: '1.65'  # theoretical
  - id: kVref
    type: float
    initial_value: '3.3'  # theoretical, 2% tolerance

  - id: kCalVoltageFactor
    type: float
    # initial_value: '1'
    initial_value: '0.9371'  # multiply measured volts by this to get true volts
  - id: kCalVoltageOffset
    type: float
    # initial_value: '0'
    initial_value: '0.0208'  # add to measured volts (post-scaling) to get true volts
  - id: kCalSetVoltageFactor
    type: float
    # initial_value: '1'
    initial_value: '0.9457'  # multiply by set volts to get true volts
  - id: kCalSetVoltageOffset
    type: float
    # initial_value: '0'
    initial_value: '-0.1642'  # add to set volts to get true volts

  - id: kCalCurrent0Factor
    type: float
    initial_value: '1'
    # initial_value: '0.98227'  # multiply measured amps by this to get true amps
  - id: kCalCurrent0Offset
    type: float
    initial_value: '0'
    # initial_value: '0.01144'  # add to measured amps (post-scaling) to get true amps
  - id: kCalCurrent1Factor
    type: float
    initial_value: '1'
    # initial_value: '0.98227'  # multiply measured amps by this to get true amps
  - id: kCalCurrent1Offset
    type: float
    initial_value: '0'
    # initial_value: '0.01144'  # add to measured amps (post-scaling) to get true amps
  - id: kCalSetCurrentFactor
    type: float
    initial_value: '1'
    # initial_value: '0.9534'  # multiply by set amps to get true amps - note varies with voltage!
  - id: kCalSetCurrentOffset
    type: float
    initial_value: '0'
    # initial_value: '0.0252'  # add to set amps to get true amps

light:
  - platform: status_led
    name: "${name} Dbg"
    id: debug_led
    pin:
      number: GPIO0
      inverted: true

output:
  - id: output_rgb_r
    platform: gpio
    pin:
      pca9554: pca9554a_device
      number: 6
      inverted: true
  - id: output_rgb_g
    platform: gpio
    pin:
      pca9554: pca9554a_device
      number: 7
      inverted: true
  - id: output_rgb_b
    platform: gpio
    pin:
      pca9554: pca9554a_device
      number: 5
      inverted: true
  # - platform: ledc
  #   pin: GPIO42
  #   id: buck_pwm
  #   frequency: 250 kHz
  # - platform: ledc
  #   pin: GPIO39  # IMPORTANT! this controls the HIGH SIDE switch, so the duty is 1-D
  #   id: boost_pwm
  #   frequency: 250 kHz
  - platform: mcpwm_sync
    id: buck_pwm
    pin: GPIO42
    frequency: 250kHz
    deadtime_rising: 0s  # deadtime generated internally by gate driver
    deadtime_falling: 0s
  - platform: mcpwm_sync
    id: boost_pwm
    pin: GPIO39  # this controls the HIGH SIDE switch, so the duty is 1-D
    frequency: 250kHz
    deadtime_rising: 0s  # deadtime generated internally by gate driver
    deadtime_falling: 0s
    max_duty: 0.37  # up to 1.5x boost ratio, accounting for 0.95 buck ratio
    inverted: true

  - platform: mcp4728
    id: dac_voltage
    mcp4728_id: dac_control
    channel: 0
  - platform: mcp4728
    id: dac_isink
    mcp4728_id: dac_control
    channel: 1
  - platform: mcp4728
    id: dac_isrc
    mcp4728_id: dac_control
    channel: 2

switch:
  - platform: gpio
    id: range0
    name: "${name} Range0"
    pin: GPIO8
    on_turn_on:
    - then:
      - switch.turn_on: control_enable
      - switch.turn_off: range1
      - output.turn_on: output_rgb_b
    on_turn_off:
    - then:
      - delay: 0.1s
      - if:
          condition:
            - switch.is_off: range0
            - switch.is_off: range1
          then:
            - switch.turn_off: control_enable
            - output.turn_off: output_rgb_b
  - platform: gpio
    id: range1
    name: "${name} Range1"
    pin: GPIO18
    on_turn_on:
    - then:
      - switch.turn_on: control_enable
      - switch.turn_off: range0
      - output.turn_on: output_rgb_b
    on_turn_off:
    - then:
      - delay: 0.1s
      - if:
          condition:
            - switch.is_off: range0
            - switch.is_off: range1
          then:
            - switch.turn_off: control_enable
            - output.turn_off: output_rgb_b
  - platform: gpio
    id: control_enable
    internal: true
    name: "${name} Control Enable"
    pin: GPIO38
  - platform: gpio
    id: conv_enable
    internal: true
    name: "${name} Conv Enable"
    pin: GPIO40
    inverted: true  # active-low enable
  - platform: gpio
    id: fan
    name: "${name} Fan"
    pin: GPIO11

i2c:
  scl: GPIO1
  sda: GPIO2
  frequency: 400kHz
  scan: false

spi:
  clk_pin: GPIO15
  mosi_pin: GPIO16
  miso_pin: GPIO17

pca9554:
  - id: pca9554a_device
    address: 0x38

fusb302:
  id: usbpd
  target: 15v

mcp3561:
  cs_pin: GPIO7
  id: adc_meas
  osr: 98304  # up to 98304


mcp4728:
  id: dac_control

font:
  - file: "resources/4x6.bdf"  # characters actually 3x5 plus 1px descender
    id: bdf4x6
  - file: "resources/6x10.bdf"  # characters actually 5x7 plus 2px descender
    id: bdf6x10
    
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3c
    reset_pin: GPIO12
    update_interval : 200ms
    lambda: |-
      it.printf(0, 0, id(bdf6x10), "Ducky SMU");

      it.printf(0, 12, id(bdf6x10), "SET  %4.1f V  %5.2f A", id(set_voltage).state, id(limit_current_min).state);
      it.printf(0, 20, id(bdf6x10), "     %s     %5.2f A", id(range0).state ? "ON " : "OFF", id(limit_current_max).state);
      it.printf(0, 32, id(bdf6x10), "MES  %4.1f V  %5.2f A", id(meas_voltage).get_state(), id(meas_current).get_state());

      const char* pdState;
      switch (id(usbpd).get_state()) {
        case UsbPdStateMachine::kConnected: pdState = "PD"; break;
        default: pdState = "  ";
      }

      it.printf(0, 64-6, id(bdf4x6), "%s", WiFi.localIP().toString().c_str());
      it.printf(128-(16*4), 64-6, id(bdf4x6), "%s %4.1fv %2.f,%2.fc", pdState, id(fusb_vbus).get_state(), id(temp_buckboost).state, id(temp_fets).state);
      if (millis() % 2000 >= 1000) {
        it.printf(128-4, 64-6, id(bdf4x6), ".");  // liveness indicator
      }

number:
  - platform: template
    name: "${name} Set Voltage"
    id: set_voltage
    icon: mdi:high-voltage
    mode: box
    min_value: 0
    max_value: 30
    step: 0.01
    unit_of_measurement: V
    set_action:
      - then:
        - lambda: |-
            float correctedX = (x - id(kCalSetVoltageOffset)) / id(kCalSetVoltageFactor);
            float targetVolts = id(kVCenter) - (correctedX / id(kVoltageRatio));
            id(dac_voltage)->write_state(targetVolts / id(kVref));
            id(set_voltage).publish_state(x);

            // set buck-boost to minimum needed + headroom
            float convTarget = x + id(kBuckBoostHeadroom);
            id(buckboost_ratio).make_call().set_value(convTarget / (id(fusb_vbus).state - 0.4)).perform();
  - platform: template
    name: "${name} Set Current Min"
    id: limit_current_min
    icon: mdi:pan-up
    mode: box
    min_value: -3
    max_value: 3
    step: 0.01
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: |-
            float correctedX = (x - id(kCalSetCurrentOffset)) / id(kCalSetCurrentFactor);
            float targetVolts = id(kVCenter) - (correctedX / id(kCurrentRatio0));
            id(dac_isink)->write_state(targetVolts / id(kVref));
            id(limit_current_min).publish_state(x);
  - platform: template
    name: "${name} Set Current Max"
    id: limit_current_max
    icon: mdi:pan-down
    mode: box
    min_value: -3
    max_value: 3
    step: 0.01
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: |-
            float correctedX = (x - id(kCalSetCurrentOffset)) / id(kCalSetCurrentFactor);
            float targetVolts = id(kVCenter) - (correctedX / id(kCurrentRatio0));
            id(dac_isrc)->write_state(targetVolts / id(kVref));
            id(limit_current_max).publish_state(x);
  - platform: template
    name: "${name} Buck-boost ratio"
    id: buckboost_ratio
    icon: mdi:pan-down
    min_value: 0
    max_value: 1.5
    step: 0.01
    set_action:
      - then:
        - lambda: |-
            // initialize DC at ratio = 1
            float buckDc = 1 - id(kBuckBoostPwmDeadzone), boostDc = id(kBuckBoostPwmDeadzone);
            if (x <= 1) {  // adjust buck dc
              float boostRatio = 1 / (1 - boostDc);
              buckDc = x / boostRatio;  // offset the minimal boost PWM
            } else {  // adjust boost dc
              float boostRatio = x / buckDc;  // offset the maximum buck PWM
              boostDc = 1 - (1 / boostRatio);
            }
            id(buck_pwm)->write_state(buckDc);
            id(boost_pwm)->write_state(boostDc);
            ESP_LOGI("BuckBoostCtl", "Target %.02f, buck %.02f, boost %.02f", x, buckDc, boostDc);
            id(buckboost_ratio).publish_state(x);

binary_sensor:
  - platform: gpio
    id: conv_en_sense
    name: "${name} Conv En Sen"
    pin: 
      number: GPIO21
      mode:
        input: true
  - platform: gpio
    id: encoder_sw
    name: "${name} Encoder Sw"
    pin: 
      number: GPIO4
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 10ms
  - platform: gpio
    id: dir_sw
    name: "${name} Dir Sw"
    pin: 
      pca9554: pca9554a_device
      number: 0
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - lambda: |-
            if (!id(range0)->state) {
              id(range0)->turn_on();
            } else {
              id(range0)->turn_off();
            }
  - platform: gpio
    id: dir_a  # up
    pin: 
      pca9554: pca9554a_device
      number: 1
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - lambda: |-
            id(set_voltage)->make_call().set_value(id(set_voltage)->state + 0.2).perform();
  - platform: gpio
    id: dir_c  # left
    pin: 
      pca9554: pca9554a_device
      number: 4
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - lambda: |-
            id(set_voltage)->make_call().set_value(id(set_voltage)->state - 0.2).perform();
  - platform: gpio
    id: dir_b  # down
    pin: 
      pca9554: pca9554a_device
      number: 2
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - lambda: |-
            if (id(limit_current_max)->state > id(limit_current_min)->state + 0.2) {  // don't allow crossover - dangerous
              id(limit_current_max)->make_call().set_value(id(limit_current_max)->state - 0.05).perform();
              id(limit_current_min)->make_call().set_value(id(limit_current_min)->state + 0.05).perform();
            }
  - platform: gpio
    id: dir_d  # right
    pin: 
      pca9554: pca9554a_device
      number: 3
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - lambda: |-
            id(limit_current_max)->make_call().set_value(id(limit_current_max)->state + 0.05).perform();
            id(limit_current_min)->make_call().set_value(id(limit_current_min)->state - 0.05).perform();

sensor:
  - platform: fusb302
    vbus:
      id: fusb_vbus
      name: "${name} PD VBus"
      filters:  # limit to 1 update/s or on fast change
        - or:
          - throttle : 1s
          - delta: 1.0
    selected_voltage:
      id: fusb_selected_voltage
      name: "${name} PD Selected Voltage"
    selected_current:
      id: fusb_selected_current
      name: "${name} PD Selected Current"
  - platform: mcp3561
    id: meas_voltage
    name: "${name} Meas Voltage"
    update_interval: 0.1s
    accuracy_decimals: 4
    mcp3561_id: adc_meas
    channel: CH2
    channel_neg: CH0  # pin 0 is vcenter
    filters:
      - lambda: |-
          id(adc_voltage).publish_state(id(meas_voltage).rawValue);
          auto value = x * id(kVref) * id(kVoltageRatio) * id(kCalVoltageFactor) + id(kCalVoltageOffset);
          id(meas_voltage_noise).publish_state(value);
          if (!isnan(id(meas_current).state)) {
            id(deriv_power).publish_state(value * id(meas_current).state);
          }
          return value;
  - platform: mcp3561
    id: meas_current
    name: "${name} Meas Current"
    update_interval: 0.1s
    accuracy_decimals: 5
    mcp3561_id: adc_meas
    channel: CH1
    channel_neg: CH0  # pin 0 is vcenter
    filters:
      - lambda: |-
          static int8_t lastRange = -1;  // -1=off, 0=range0, 1=...
          int8_t thisRange = -1;
          if (id(range0)->state && !id(range1)->state) {
            thisRange = 0;
          } else if (id(range1)->state && !id(range0)->state) {
            thisRange = 1;
          }
          id(adc_current).publish_state(id(meas_current).rawValue);

          if (lastRange != thisRange || thisRange < 0) {  // invalidate the measurement on a range change
            lastRange = thisRange;
            id(deriv_power).publish_state(NAN);
            return NAN;
          }

          auto value = x * id(kVref);
          if (thisRange == 0) {
            value = value * id(kCurrentRatio0) * id(kCalCurrent0Factor) + id(kCalCurrent0Offset);
          } else if (thisRange == 1) {
            value = value * id(kCurrentRatio1) * id(kCalCurrent1Factor) + id(kCalCurrent1Offset);
          }
          id(meas_current_noise).publish_state(value);
          id(deriv_power).publish_state(id(meas_voltage).state * value);
          return value;
    unit_of_measurement: A
  - platform: template
    name: "${name} Meas Voltage Noise"
    id: meas_voltage_noise
    accuracy_decimals: 6
    filters:
      - range:
          window_size: 25
          send_every: 5
  - platform: template
    name: "${name} Meas Current Noise"
    id: meas_current_noise
    accuracy_decimals: 7
    filters:
      - range:
          window_size: 25
          send_every: 5

  - platform: template
    name: "${name} Deriv Power"
    id: deriv_power
    accuracy_decimals: 6
    unit_of_measurement: W
  - platform: integration
    name: "${name} Deriv Energy"
    sensor: deriv_power
    time_unit: s
    accuracy_decimals: 6
    unit_of_measurement: J
  - platform: integration
    name: "${name} Deriv Cumulative Current"
    sensor: meas_current
    time_unit: h
    accuracy_decimals: 6
    unit_of_measurement: Ah

  - platform: template
    name: "${name} Meas ADC Voltage"
    id: adc_voltage
    accuracy_decimals: 0
    internal: true
  - platform: template
    name: "${name} Meas ADC Current"
    id: adc_current
    accuracy_decimals: 0
    internal: true
    
  # - platform: mcp3561  # TESTING OUTPUT for absolute ADC output
  #   name: "${name} Int VCenter"
  #   update_interval: 1s
  #   mcp3561_id: adc_meas
  #   channel: CH0
  #   channel_neg: AGND
  #   filters:
  #     - lambda: |-
  #         return x * id(kVref);

  - platform: adc
    id: adc_vconv
    name: "${name} Int VConv"
    pin: GPIO10
    accuracy_decimals: 2
    update_interval: 0.25s
    attenuation: auto
    filters:
      - multiply: 14
 
  - platform: tmp1075n
    id: temp_fets
    address: 0x48
    name: "${name} Temp FETs"
    update_interval: 1s
  - platform: tmp1075n
    id: temp_buckboost
    address: 0x49
    name: "${name} Temp Buck-boost"
    update_interval: 1s

  - platform: rotary_encoder
    id: encoder
    name: "${name} Encoder"
    resolution: 2  # so each detent generates one action
    pin_a:
      number: GPIO5
      inverted: true
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO6
      inverted: true
      mode:
        input: true
        pullup: true
    on_clockwise:
    - then:
        - lambda: ;
    on_anticlockwise:
    - then:
        - lambda: ;
