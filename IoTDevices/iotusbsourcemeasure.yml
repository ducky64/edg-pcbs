substitutions:
  name: "UsbSMU"

esphome:
  name: ducky-iotusbsmu
  name_add_mac_suffix: true
  platform: esp32
  board: esp32-s3-devkitc-1  # 8MB flash without PSRAM
  on_boot:
    - output.set_level:
        id: boot_pwm
        level: "50%"
    - number.set:
        id: set_voltage
        value: 0
    - number.set:
        id: limit_current_min
        value: -0.1
    - number.set:
        id: limit_current_max
        value: 0.1
    - number.set:
        id: buckboost_ratio
        value: 1.0

wifi:
  <<: !include ../wifi_config.yaml
  ap:
    ap_timeout: 15s

  reboot_timeout: 0s

# HASS API
api:
  reboot_timeout: 0s

# Allow API
ota:

# Print Updates
logger:
  level: INFO

# WebServer component, displays some information
web_server:
    port: 80
    local: true

# device constants
globals:
  - id: kVoltageRatio
    type: float
    initial_value: '24'  # output volts per measured volt
  - id: kCurrentRatio
    type: float
    initial_value: '1'  # output amps per measured volt, including accounting for resistor value
  - id: kVCenter
    type: float
    initial_value: '1.498'  # theoretical and measured
  - id: kAdcVref
    type: float
    initial_value: '2.4'  # theoretical, 2% tolerance
  - id: kDacVRef
    type: float
    initial_value: '3.3'  # theoretical
  - id: kBuckBoostPwmDeadzone
    type: float
    initial_value: '0.05'  # in fractional duty-cycle, maximum / minimum duty cycle
  - id: kMaxBoostRatio
    type: float
    initial_value: '1.5'  # in fractional duty-cycle, maximum / minimum duty cycle
  - id: kCalVoltageFactor
    type: float
    # initial_value: '1'
    initial_value: '1.0000'  # multiply measured volts by this to get true volts
  - id: kCalVoltageOffset
    type: float
    # initial_value: '0'
    initial_value: '0.0247'  # add to measured volts (post-scaling) to get true volts
  - id: kCalCurrentFactor
    type: float
    # initial_value: '1'
    initial_value: '0.9824'  # multiply measured amps by this to get true amps
  - id: kCalCurrentOffset
    type: float
    # initial_value: '0'
    initial_value: '0.0114'  # add to measured amps (post-scaling) to get true amps
  - id: kCalCurrentVoltageFactor
    type: float
    # initial_value: '0'
    initial_value: '-0.0035'  # multiply by measured volts (post-calibration, then add to measured amps (post-scaling) to get true amps
    # obtained using https://stats.blue/Stats_Suite/multiple_linear_regression_calculator.html

light:
  - platform: binary
    name: "${name} Dbg"
    id: debug_led
    output: output_debug_led

output:
  - id: output_debug_led
    platform: gpio
    pin: GPIO0
    inverted: true
  - id: output_rgb_r
    platform: gpio
    pin: GPIO13
    inverted: true
  - id: output_rgb_g
    platform: gpio
    pin: GPIO12
    inverted: true
  - id: output_rgb_b
    platform: gpio
    pin: GPIO14
    inverted: true
  - platform: ledc
    pin: GPIO2
    id: boot_pwm
    frequency: 1 MHz
  - platform: mcpwm_sync
    id: buck_pwm
    pin: GPIO40  # high-side
    pin_comp: GPIO42  # low-side
    frequency: 200kHz
    deadtime_rising: 100ns
    deadtime_falling: 100ns
  - platform: mcpwm_sync
    id: boost_pwm
    pin: GPIO39  # low-side
    pin_comp: GPIO38  # high-side
    frequency: 200kHz
    deadtime_rising: 100ns
    deadtime_falling: 100ns
    max_duty: 0.37  # up to 1.5x boost ratio + accounting for deadzone

  - platform: mcp4728
    id: dac_voltage
    mcp4728_id: dac_control
    channel: 0
  - platform: mcp4728
    id: dac_isink
    mcp4728_id: dac_control
    channel: 1
  - platform: mcp4728
    id: dac_isrc
    mcp4728_id: dac_control
    channel: 2

switch:
  - platform: gpio
    id: driver_enable
    name: "${name} Driver Enable"
    pin: GPIO18
    on_turn_on:
    - then:
      - switch.turn_on: control_enable
    on_turn_off:
    - then:
      - switch.turn_off: control_enable
  - platform: gpio
    id: control_enable
    internal: true
    name: "${name} Control Enable"
    pin: GPIO8

i2c:
  scl: GPIO15
  sda: GPIO16
  frequency: 400kHz
  scan: false

spi:
  clk_pin: GPIO5
  mosi_pin: GPIO6
  miso_pin: GPIO7

pca9554:
  - id: pca9554a_device
    address: 0x38

fusb302:
  id: usbpd
  target: 12v

mcp3561:
  cs_pin: GPIO4
  id: adc_meas
  osr: 16384

mcp4728:
  id: dac_control

font:
  - file: "resources/4x6.bdf"  # characters actually 3x5 plus 1px descender
    id: bdf4x6
  - file: "resources/6x10.bdf"  # characters actually 5x7 plus 2px descender
    id: bdf6x10
    
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3c
    reset_pin: GPIO21
    update_interval : 200ms
    lambda: |-
      it.printf(0, 0, id(bdf6x10), "Ducky SMU");

      it.printf(0, 12, id(bdf6x10), "SET  %4.1f V  %5.2f A", id(set_voltage).state, id(limit_current_min).state);
      it.printf(0, 20, id(bdf6x10), "     %s     %5.2f A", id(driver_enable).state ? "ON " : "OFF", id(limit_current_max).state);
      it.printf(0, 32, id(bdf6x10), "MES  %4.1f V  %5.2f A", id(meas_voltage).get_state(), id(meas_current).get_state());

      const char* pdState;
      switch (id(usbpd).get_state()) {
        case UsbPdStateMachine::kConnected: pdState = "PD"; break;
        default: pdState = "  ";
      }

      it.printf(0, 64-6, id(bdf4x6), "%s", WiFi.localIP().toString().c_str());
      it.printf(128-(16*4), 64-6, id(bdf4x6), "%s %4.1fv %2.f,%2.fc", pdState, id(fusb_vbus).get_state(), id(temp_buckboost).state, id(temp_fets).state);
      if (millis() % 2000 >= 1000) {
        it.printf(128-4, 64-6, id(bdf4x6), ".");  // liveness indicator
      }

number:
  - platform: template
    name: "${name} Set Voltage"
    id: set_voltage
    icon: mdi:high-voltage
    min_value: 0
    max_value: 30
    step: 0.01
    unit_of_measurement: V
    set_action:
      - then:
        - lambda: |-
            float targetVolts = id(kVCenter) - (x / id(kVoltageRatio));
            id(dac_voltage)->write_state(targetVolts / id(kDacVRef));
            id(set_voltage).publish_state(x);
  - platform: template
    name: "${name} Set Current Min"
    id: limit_current_min
    icon: mdi:pan-up
    min_value: -1
    max_value: 1
    step: 0.01
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: |-
            float targetVolts = id(kVCenter) - (x / id(kCurrentRatio));
            id(dac_isink)->write_state(targetVolts / id(kDacVRef));
            id(limit_current_min).publish_state(x);
  - platform: template
    name: "${name} Set Current Max"
    id: limit_current_max
    icon: mdi:pan-down
    min_value: -1
    max_value: 1
    step: 0.01
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: |-
            float targetVolts = id(kVCenter) - (x / id(kCurrentRatio));
            id(dac_isrc)->write_state(targetVolts / id(kDacVRef));
            id(limit_current_max).publish_state(x);
  - platform: template
    name: "${name} Buck-boost ratio"
    id: buckboost_ratio
    icon: mdi:pan-down
    min_value: 0
    max_value: 1.5
    step: 0.01
    set_action:
      - then:
        - lambda: |-
            float buckDc = 1 - id(kBuckBoostPwmDeadzone), boostDc = id(kBuckBoostPwmDeadzone);
            if (x > id(kMaxBoostRatio)) {  // clamp if needed
              x = id(kMaxBoostRatio);
            }
            if (x <= 1) {  // adjust buck dc
              float boostRatio = 1 / (1 - boostDc);
              buckDc = x / boostRatio;  // offset the minimal boost PWM
            } else {  // adjust boost dc
              float boostRatio = x / buckDc;  // offset the maximum buck PWM
              boostDc = 1 - (1 / boostRatio);
            }
            id(buck_pwm)->write_state(buckDc);
            id(boost_pwm)->write_state(boostDc);
            ESP_LOGI("BuckBoostCtl", "Target %.02f, buck %.02f, boost %.02f", x, buckDc, boostDc);
            id(buckboost_ratio).publish_state(x);

binary_sensor:
  # - platform: gpio
  #   id: encoder_sw
  #   name: "${name} Encoder Sw"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 6
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  - platform: gpio
    id: dir_sw
    name: "${name} Dir Sw"
    pin: 
      pca9554: pca9554a_device
      number: 2
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_a
  #   name: "${name} Dir U"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 1
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_b
  #   name: "${name} Dir R"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 7
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_c
  #   name: "${name} Dir L"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 3
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_d
  #   name: "${name} Dir D"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 0
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms

sensor:
  - platform: fusb302
    vbus:
      id: fusb_vbus
      name: "${name} PD VBus"
      filters:  # limit to 1 update/s or on fast change
        - or:
          - throttle : 1s
          - delta: 1.0
    selected_voltage:
      id: fusb_selected_voltage
      name: "${name} PD Selected Voltage"
    selected_current:
      id: fusb_selected_current
      name: "${name} PD Selected Current"
  - platform: mcp3561
    id: meas_voltage
    name: "${name} Meas Voltage"
    update_interval: 0.1s
    mcp3561_id: adc_meas
    channel: CH2
    channel_neg: CH0  # pin 0 is vcenter
    filters:
      - lambda: |-
          id(adc_voltage).publish_state(id(meas_voltage).rawValue);
          return x * id(kAdcVref) * id(kVoltageRatio) * id(kCalVoltageFactor) + id(kCalVoltageOffset);

  - platform: mcp3561
    id: meas_current
    name: "${name} Meas Current"
    update_interval: 0.1s
    mcp3561_id: adc_meas
    channel: CH1
    channel_neg: CH0  # pin 0 is vcenter
    filters:
      - lambda: |-
          id(adc_current).publish_state(id(meas_current).rawValue);
          return x * id(kAdcVref) * id(kCurrentRatio) * id(kCalCurrentFactor) + id(kCalCurrentOffset) + id(kCalCurrentVoltageFactor) * id(meas_voltage).get_state();
    unit_of_measurement: A
  - platform: template
    name: "${name} Meas ADC Voltage"
    id: adc_voltage
    accuracy_decimals: 0
  - platform: template
    name: "${name} Meas ADC Current"
    id: adc_current
    accuracy_decimals: 0
  # - platform: mcp3561  # TESTING OUTPUT for absolute ADC output
  #   name: "${name} Int VCenter"
  #   update_interval: 1s
  #   mcp3561_id: adc_meas
  #   channel: CH0
  #   channel_neg: AGND
  #   filters:
  #     - lambda: |-
  #         return x * id(kAdcVref);

  - platform: adc
    id: adc_vconv
    name: "${name} Int VConv"
    pin: GPIO10
    accuracy_decimals: 2
    update_interval: 0.25s
    attenuation: auto
    filters:
      - multiply: 14
 
  - platform: tmp1075n
    id: temp_fets
    address: 0x48
    name: "${name} Temp FETs"
    update_interval: 1s
  - platform: tmp1075n
    id: temp_buckboost
    address: 0x49
    name: "${name} Temp Buck-boost"
    update_interval: 1s

  # - platform: rotary_encoder
  #   id: encoder
  #   name: "${name} Encoder"
  #   resolution: 2  # so each detent generates one action
  #   pin_a:
  #     number: 4
  #     inverted: true
  #     mode:
  #       input: true
  #       pullup: true
  #   pin_b:
  #     number: GPIO16
  #     inverted: true
  #     mode:
  #       input: true
  #       pullup: true
  #   on_clockwise:
  #   - then:
  #       - lambda: ;
  #   on_anticlockwise:
  #   - then:
  #       - lambda: ;
