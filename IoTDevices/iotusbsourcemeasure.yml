substitutions:
  name: "UsbSMU"

esphome:
  name: ducky-iotusbsmu
  name_add_mac_suffix: true
  platform: esp32
  board: esp32-s3-devkitc-1  # 8MB flash without PSRAM
  on_boot:
    - output.set_level:
        id: boot_pwm
        level: "50%"
    - number.set:
        id: set_voltage
        value: 0
    - number.set:
        id: limit_current_min
        value: -0.1
    - number.set:
        id: limit_current_max
        value: 0.1
    - number.set:
        id: buckboost_ratio
        value: 1.0

wifi:
  <<: !include ../wifi_config.yaml
  reboot_timeout: 0s

# HASS API
api:
  reboot_timeout: 0s

# Allow API
ota:

# Print Updates
logger:
  level: INFO

# WebServer component, displays some information
web_server:
    port: 80

# device constants
globals:
  - id: kVoltageRatio
    type: float
    initial_value: '24'  # output volts per measured volt
  - id: kCurrentRatio
    type: float
    initial_value: '1'  # output amps per measured volt, including accounting for resistor value
  - id: kVCenter
    type: float
    initial_value: '1.498'  # theoretical and measured
  - id: kDacVRef
    type: float
    initial_value: '3.284'  # measured, off a LDO
  - id: kBuckBoostPwmDeadzone
    type: float
    initial_value: '0.05'  # in fractional duty-cycle, maximum / minimum duty cycle
  - id: kMaxBoostRatio
    type: float
    initial_value: '1.5'  # in fractional duty-cycle, maximum / minimum duty cycle

light:
  - platform: binary
    name: "${name} Dbg"
    id: debug_led
    output: output_debug_led

output:
  - id: output_debug_led
    platform: gpio
    pin: GPIO0
    inverted: true
  - id: output_rgb_r
    platform: gpio
    pin: GPIO13
    inverted: true
  - id: output_rgb_g
    platform: gpio
    pin: GPIO12
    inverted: true
  - id: output_rgb_b
    platform: gpio
    pin: GPIO14
    inverted: true
  - platform: ledc
    pin: GPIO2
    id: boot_pwm
    frequency: 1 MHz
  - platform: mcpwm_sync
    id: buck_pwm
    pin: GPIO40  # high-side
    pin_comp: GPIO42  # low-side
    frequency: 200kHz
    deadtime_rising: 100ns
    deadtime_falling: 100ns
  - platform: mcpwm_sync
    id: boost_pwm
    pin: GPIO39  # low-side
    pin_comp: GPIO38  # high-side
    frequency: 200kHz
    deadtime_rising: 100ns
    deadtime_falling: 100ns
    max_duty: 0.37  # up to 1.5x boost ratio + accounting for deadzone

  - platform: mcp4728
    id: dac_voltage
    mcp4728_id: dac_control
    channel: 0
  - platform: mcp4728
    id: dac_isink
    mcp4728_id: dac_control
    channel: 1
  - platform: mcp4728
    id: dac_isrc
    mcp4728_id: dac_control
    channel: 2

switch:
  - platform: gpio
    name: "${name} Driver Enable"
    pin: GPIO18
  - platform: gpio
    name: "${name} Control Enable"
    pin: GPIO8
    inverted: true

i2c:
  scl: GPIO15
  sda: GPIO16
  frequency: 400kHz
  scan: false

spi:
  clk_pin: GPIO5
  mosi_pin: GPIO6
  miso_pin: GPIO7

pca9554:
  - id: pca9554a_device
    address: 0x38

fusb302:
  id: usbpd
  target: 9v

mcp3561:
  cs_pin: GPIO4
  id: adc_meas
  osr: 16384

mcp4728:
  id: dac_control

font:
  - file: "resources/4x6.bdf"  # characters actually 3x5 plus 1px descender
    id: bdf4x6
  - file: "resources/6x10.bdf"  # characters actually 5x7 plus 2px descender
    id: bdf6x10
    
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3c
    reset_pin: GPIO21
    update_interval : 200ms
    lambda: |-
      it.printf(0, 0, id(bdf6x10), "Ducky SMU");

      const char* pdState;
      switch (id(usbpd).get_state()) {
        case UsbPdStateMachine::kStart: pdState = "DIS";
        case UsbPdStateMachine::kConnected: pdState = "CON";
        default: pdState = "...";
      }
      it.printf(0, 64-6-10, id(bdf6x10), "USB  %2.1f V  %s", id(fusb_vbus).get_state(), pdState);

      it.printf(0, 64-6, id(bdf4x6), "%s", WiFi.localIP().toString().c_str());
      it.printf(128-(8*4), 64-6, id(bdf4x6), "%2.0f, %2.0f C", id(temp_buckboost).state, id(temp_fets).state);

number:
  - platform: template
    name: "${name} Set Voltage"
    id: set_voltage
    icon: mdi:high-voltage
    min_value: 0
    max_value: 30
    step: 0.01
    unit_of_measurement: V
    set_action:
      - then:
        - lambda: |-
            float targetVolts = id(kVCenter) - (x / id(kVoltageRatio));
            id(dac_voltage)->write_state(targetVolts / id(kDacVRef));
            id(set_voltage).publish_state(x);
  - platform: template
    name: "${name} Set Current Min"
    id: limit_current_min
    icon: mdi:pan-up
    min_value: -1
    max_value: 1
    step: 0.01
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: |-
            float targetVolts = id(kVCenter) - (x / id(kCurrentRatio));
            id(dac_isink)->write_state(targetVolts / id(kDacVRef));
            id(limit_current_min).publish_state(x);
  - platform: template
    name: "${name} Set Current Max"
    id: limit_current_max
    icon: mdi:pan-down
    min_value: -1
    max_value: 1
    step: 0.01
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: |-
            float targetVolts = id(kVCenter) - (x / id(kCurrentRatio));
            id(dac_isrc)->write_state(targetVolts / id(kDacVRef));
            id(limit_current_max).publish_state(x);
  - platform: template
    name: "${name} Buck-boost ratio"
    id: buckboost_ratio
    icon: mdi:pan-down
    min_value: 0
    max_value: 1.5
    step: 0.01
    set_action:
      - then:
        - lambda: |-
            float buckDc = 1 - id(kBuckBoostPwmDeadzone), boostDc = id(kBuckBoostPwmDeadzone);
            if (x > id(kMaxBoostRatio)) {  // clamp if needed
              x = id(kMaxBoostRatio);
            }
            if (x <= 1) {  // adjust buck dc
              float boostRatio = 1 / (1 - boostDc);
              buckDc = x / boostRatio;  // offset the minimal boost PWM
            } else {  // adjust boost dc
              float boostRatio = x / buckDc;  // offset the maximum buck PWM
              boostDc = 1 - (1 / boostRatio);
            }
            id(buck_pwm)->write_state(buckDc);
            id(boost_pwm)->write_state(boostDc);
            ESP_LOGI("BuckBoostCtl", "Target %.02f, buck %.02f, boost %.02f", x, buckDc, boostDc);
            id(buckboost_ratio).publish_state(x);

binary_sensor:
  # - platform: gpio
  #   id: encoder_sw
  #   name: "${name} Encoder Sw"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 6
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  - platform: gpio
    id: dir_sw
    name: "${name} Dir Sw"
    pin: 
      pca9554: pca9554a_device
      number: 2
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_a
  #   name: "${name} Dir U"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 1
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_b
  #   name: "${name} Dir R"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 7
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_c
  #   name: "${name} Dir L"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 3
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms
  # - platform: gpio
  #   id: dir_d
  #   name: "${name} Dir D"
  #   pin: 
  #     pca9554: pca9554a_device
  #     number: 0
  #     inverted: true
  #     mode:
  #       input: true
  #   filters:
  #     - delayed_on: 10ms

sensor:
  - platform: fusb302
    vbus:
      id: fusb_vbus
      name: "${name} PD VBus"
    selected_voltage:
      id: fusb_selected_voltage
      name: "${name} PD Selected Voltage"
    selected_current:
      id: fusb_selected_current
      name: "${name} PD Selected Current"
  - platform: mcp3561
    id: vmeas
    name: "${name} Meas Voltage"
    update_interval: 0.25s
    mcp3561_id: adc_meas
    channel: CH2
    channel_neg: CH0  # pin 0 is vcenter
  - platform: mcp3561
    id: imeas
    name: "${name} Meas Current"
    update_interval: 0.25s
    mcp3561_id: adc_meas
    channel: CH1
    channel_neg: CH0  # pin 0 is vcenter
    filters:
      - lambda: return x * id(kCurrentRatio);
      - calibrate_linear:
          method: least_squares
          datapoints:  # sensor -> true, 50 ohm load
            - -0.0051015 -> 0
            - 0.0328085 -> 0.032
            - 0.0773658 -> 0.070
            - 0.1424263 -> 0.124
            - 0.1910073 -> 0.165
            - 0.2388536 -> 0.205
            - 0.2864064 -> 0.245
            - -0.0050609 -> 0
            # - 0.2566624 -> 0.249  # 10 ohm load constants below
            # - 0.5583450 -> 0.532
            # - 0.7941853 -> 0.756
            # - 1.0255989 -> 0.975
    unit_of_measurement: A
  - platform: mcp3561  # TESTING OUTPUT for absolute ADC output
    name: "${name} Int VCenter"
    update_interval: 1s
    mcp3561_id: adc_meas
    channel: CH0
    channel_neg: AGND

  - platform: adc
    id: adc_vconv
    name: "${name} Int VConv"
    pin: GPIO10
    accuracy_decimals: 2
    update_interval: 0.25s
    attenuation: auto
    filters:
      - multiply: 14
 
  - platform: tmp1075n
    id: temp_fets
    address: 0x48
    name: "${name} Temp FETs"
    update_interval: 1s
  - platform: tmp1075n
    id: temp_buckboost
    address: 0x49
    name: "${name} Temp Buck-boost"
    update_interval: 1s

  # - platform: rotary_encoder
  #   id: encoder
  #   name: "${name} Encoder"
  #   resolution: 2  # so each detent generates one action
  #   pin_a:
  #     number: 4
  #     inverted: true
  #     mode:
  #       input: true
  #       pullup: true
  #   pin_b:
  #     number: GPIO16
  #     inverted: true
  #     mode:
  #       input: true
  #       pullup: true
  #   on_clockwise:
  #   - then:
  #       - lambda: ;
  #   on_anticlockwise:
  #   - then:
  #       - lambda: ;
