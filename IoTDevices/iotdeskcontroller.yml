substitutions:
  name: "DeskController"

esphome:
  name: ducky-deskcontroller
  name_add_mac_suffix: true
  platform: esp32
  board: esp32-c3-devkitm-1
  on_boot:
    priority: 0  # when mostly everything else is done
    then:
      - lambda: pinMode(6, OUTPUT_OPEN_DRAIN );  // mode not set correctly in matrix_keypad
      - delay: 0.1s  # give controller a chance to handle the response before sending the next command
      - lambda: "id(desk).request_physical_limits();"
      - delay: 0.1s
      - lambda: "id(desk).request_limits();"
      - delay: 0.1s
      - lambda: "id(desk).request_settings();"

external_components:
  - source:
      type: git
      url: https://github.com/Rocka84/esphome_components/
    components: [ jiecang_desk_controller ]

# logger:  # for debugging desk controller component
#   level: VERBOSE
#   logs:
    # jiecang_desk_controller: VERBOSE


# device constants
globals:
  - id: kBrightnessBackground
    type: float
    initial_value: '0.15'
  - id: kBrightnessActive
    type: float
    initial_value: '0.33'
  - id: DeskMem1Pos  # cm, local stored copy
    type: float
    restore_value: true
    initial_value: '0'
  - id: DeskMem2Pos
    type: float
    restore_value: true
    initial_value: '0'
  - id: DeskMem3Pos
    type: float
    restore_value: true
    initial_value: '0'
  - id: DeskMem4Pos
    type: float
    restore_value: true
    initial_value: '0'

script:
  - id: NpxSet  # helper function to make LED ops take less lines
    parameters:
      lednum: int  # 1
      bright: float  # 0-1
      red: float  # 0-1
      green: float
      blue: float
      duration_ms: int  # 0 to latch
    then:
      - light.addressable_set:
          id: led
          range_from: !lambda return lednum - 1;
          range_to: !lambda return lednum - 1;
          red: !lambda return red * bright;
          green: !lambda return green * bright;
          blue: !lambda return blue * bright;
      - if:
          condition:
            - lambda: return duration_ms > 0;
          then:
            - delay: !lambda return duration_ms;
            - light.addressable_set:
                id: led
                range_from: !lambda return lednum - 1;
                range_to: !lambda return lednum - 1;
                red: 0
                green: 0
                blue: 0

wifi:
  <<: !include ../wifi_config.yaml

<<: !include ../common_config.yaml

uart:
  id: desk_uart
  tx_pin: GPIO5
  rx_pin: GPIO4
  baud_rate: 9600
  debug:
    direction: BOTH
    dummy_receiver: true
    after:
      delimiter: [0x7E]
      # timeout: 5ms
    sequence:
        # Use mulcmu's method for reading uart without a custome component: https://community.home-assistant.io/t/how-to-uart-read-without-custom-component/491950?u=mahko_mahko
      - lambda: |-
          UARTDebug::log_int(direction, bytes, ',');                // Log the message as int. Good for height message checks.
          UARTDebug::log_hex(direction, bytes, ',');                // Log the message in hex. Good for checking against protocol documentation.
          
# based on https://github.com/Rocka84/esphome_components/blob/master/components/jiecang_desk_controller/example_basic.yaml
# note, protocol reverse engineering here: https://gitlab.com/pimp-my-desk/desk-control/jiecang-reverse-engineering
# and https://github.com/phord/Jarvis
jiecang_desk_controller:
  id: desk
  buttons:
    step_up:
      name: "Step up"
    step_down:
      name: "Step down"
    position1:
      name: "Position 1"
    position2:
      name: "Position 2"
    position3:
      name: "Position 3"
    position4:
      name: "Position 4"
  numbers:
    height:
      id: desk_height
      name: "Height"
    height_pct:
      id: desk_height_pct
      name: "Height Pct"
  sensors:
    height_min:
      id: desk_height_min
      name: "Height Min"
    height_max:
      id: desk_height_max
      name: "Height Max"

matrix_keypad:
  id: keypad
  rows:
    - pin: 
        number: GPIO6
        mode: OUTPUT_OPEN_DRAIN  # this doesn't actually work
    - pin:
        number: GPIO3
        mode: OUTPUT_OPEN_DRAIN

  columns:
    - pin:
        number: GPIO19
        mode: INPUT_PULLUP
    - pin:
        number: GPIO18
        mode: INPUT_PULLUP
    - pin:
        number: GPIO10
        mode: INPUT_PULLUP

  keys: "012345"

binary_sensor:
  - platform: matrix_keypad
    keypad_id: keypad
    name: "Key0"
    key: 0
    on_click:
    - min_length: 10ms
      max_length: 999ms
      then:
        - lambda: id(desk).goto_position(1);
        - lambda: id(NpxSet).execute(1, id(kBrightnessBackground), 0, 1, 0, 0);
    - min_length: 2000ms
      max_length: 3000ms
      then:
        - lambda: id(desk).save_position(1);
        - lambda: id(NpxSet).execute(1, id(kBrightnessActive), 0, 1, 0, 250);
  - platform: matrix_keypad
    keypad_id: keypad
    name: "Key1"
    key: 1
    on_click:
    - min_length: 10ms
      max_length: 999ms
      then:
        - lambda: id(desk).goto_position(2);
        - lambda: id(NpxSet).execute(2, id(kBrightnessBackground), 1, 0, 0, 0);
    - min_length: 2000ms
      max_length: 3000ms
      then:
        - lambda: id(desk).save_position(2);
        - lambda: id(NpxSet).execute(2, id(kBrightnessActive), 1, 0, 0, 250);
  - platform: matrix_keypad
    keypad_id: keypad
    name: "Key2"
    key: 2
    on_press:
      then:
        - lambda: "id(desk).request_physical_limits();"
        - delay: 0.1s
        - lambda: "id(desk).request_limits();"
        - delay: 0.1s
        - lambda: "id(desk).request_settings();"
  - platform: matrix_keypad
    keypad_id: keypad
    name: "Key3"
    key: 3
    on_press:
      then:
        - lambda: id(desk).goto_height(50);
        - lambda: ESP_LOGI("top", "GOTO 50");
        - rtttl.play: 'two_short:d=4,o=5,b=100:16e6,16e6'
  - platform: matrix_keypad
    keypad_id: keypad
    id: keypad_4
    name: "Key4"
    key: 4
    on_state:
      - while:
          condition:
            binary_sensor.is_on: keypad_4
          then:
            - lambda: id(desk).step_down();
            - delay: 250ms
    on_release:
      then:
        - lambda: id(desk).stop();

  - platform: matrix_keypad
    keypad_id: keypad
    id: keypad_5
    name: "Key5"
    key: 5
    on_state:
      - while:
          condition:
            binary_sensor.is_on: keypad_5
          then:
            - lambda: id(desk).step_up();
            - delay: 250ms
    on_release:
      then:
        - lambda: id(desk).stop();

light:
  - platform: neopixelbus  # seens to work better than esp32_rmt_led_strip
    id: led
    variant: sk6812
    pin: GPIO7
    num_leds: 6
    name: "${name} Neopixels"
    effects:
      - addressable_rainbow:
          name: Rainbow
  - platform: status_led
    name: "${name} Dbg"
    id: debug_led
    internal: true
    pin:
      number: GPIO9
      inverted: true

output:
  - platform: ledc
    pin: GPIO8
    id: rtttl_out

rtttl:
  output: rtttl_out
  gain: 1%

i2c:
  scl: GPIO1
  sda: GPIO0
  frequency: 400kHz
  scan: false

font:
  - file: "resources/4x6.bdf"  # characters actually 3x5 plus 1px descender
    id: bdf4x6
  - file: "resources/6x10.bdf"  # characters actually 5x7 plus 2px descender
    id: bdf6x10

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3c
    reset_pin: GPIO2
    update_interval : 200ms
    lambda: |-
      it.printf(0, 0, id(bdf6x10), TextAlign::TOP_LEFT, "%.1f / %.0f%%", id(desk_height).state, id(desk_height_pct).state);
      it.printf(0, 8, id(bdf6x10), TextAlign::TOP_LEFT, "%.1f - %1.f", id(desk_height_min).state, id(desk_height_max).state);

      // char wifiSsidTrunc[16] = {0};
      // strncpy(wifiSsidTrunc, WiFi.SSID().c_str(), 15);
      // it.print(0, 64-6, id(bdf4x6), TextAlign::BOTTOM_LEFT, wifiSsidTrunc);
      it.print(0, 64, id(bdf4x6), TextAlign::BOTTOM_LEFT, WiFi.localIP().toString().c_str());
      it.printf(128, 64, id(bdf4x6), TextAlign::BOTTOM_RIGHT, "Ducky Desk");
